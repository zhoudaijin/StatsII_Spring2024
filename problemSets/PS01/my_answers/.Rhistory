# Question 1
# 1-1
# Run linear regression model
regression_model <- lm(voteshare ~ difflog, data = inc.sub)
# Check the result of regression model
summary(regression_model)
# 1-2
library(ggplot2)
# Make scatterplot of the two variables and add the regression line by using ggplot
ggplot(inc.sub, aes(x = difflog, y = voteshare))+
geom_point() + # Add scatterplot
geom_smooth(method = "lm", se = FALSE) + # Add the regression line
labs(x = "Difflog", y = "Voteshare") + # Add axis labels
ggtitle("Scatterplot with Regression Line (Voteshare ~ difflog *1-2*)") # Add title
# 1-3
# Save the residuals of the model in a separate object
residuals <- resid(regression_model)
# Check the head line of residuals
head(residuals)
# Abstract fitted values
fitted_values <- fitted(regression_model)
# Plot residuals
plot(fitted_values, residuals, xlab = "Fitted values", ylab = "Residuals")
abline(h = 0, col = "blue", lty = 2)
plot (density(residuals) ,
main= " Density of residuals " ,
ylab = "Y" , xlab = "X" ,
cex.axis = 1.5 , cex.lab = 2, cex.main = 1.5 , lwd = 3 )
fitted_values <- fitted(regression_model)
fitted_values <- fitted(regression_model)
fitted_values
plot(fitted_values, residuals, xlab = "Fitted values", ylab = "Residuals")
abline(h = 0, col = "blue", lty = 2)
plot (density(residuals) ,
main= " Density of residuals " ,
ylab = "Y" , xlab = "X" ,
cex.axis = 1.5 , cex.lab = 2, cex.main = 1.5 , lwd = 3 )
cat(voteshare = round(intercept, digits = 2) + round(intercept, digits = 2) * diddlog)
cat("voteshare" = round(intercept, digits = 2) + round(intercept, digits = 2) * "diddlog")
intercept <- coefficients_package[1]
print(round(intercept, digits = 2))
coef_diddlog <- coefficients_package[2]
print(round(intercept, digits = 2))
intercept <- coefficients_package[1]
print(round(intercept, digits = 2))
coef_diddlog <- coefficients_package[2]
print(round(coef_diddlog, digits = 2))
plot(fitted_values, residuals, xlab = "Fitted values", ylab = "Residuals")
abline(h = 0, col = "blue", lty = 2)
# Perform linear regression analysis
regression_model_2 <- lm(presvote ~ difflog, data = inc.sub)
# Check the result of regression model
summary(regression_model_2)
# Take the coefficients from model
coefficients_package_2 <- coef(regression_model_2)
print(coefficients_package_2)
# Sort the coefficients from coefficients package
intercept_2 <- coefficients_package_2[1]
print(round(intercept_2, digits = 2))
coef_diddlog_2 <- coefficients_package_2[2]
print(round(coef_diddlog_2, digits = 2))
# Save the residuals of the model in a separate object
residuals_2 <- resid(regression_model_2)
# Check the head line of residuals_2
head(residuals_2)
# Abstract fitted values
fitted_values_2 <- fitted(regression_model)
# Plot residuals
plot(fitted_values_2, residuals_2, xlab = "Fitted values", ylab = "Residuals")
abline(h = 0, col = "blue", lty = 2)
# Check whether the residual follows the normal distribution
plot (density(residuals_2) ,
main= " Density of residuals " ,
ylab = "Y" , xlab = "X" ,
cex.axis = 1.5 , cex.lab = 2, cex.main = 1.5 , lwd = 3 )
plot(fitted_values_2, residuals_2, xlab = "Fitted values", ylab = "Residuals")
abline(h = 0, col = "blue", lty = 2)
plot (density(residuals_2) ,
main= " Density of residuals " ,
ylab = "Y" , xlab = "X" ,
cex.axis = 1.5 , cex.lab = 2, cex.main = 1.5 , lwd = 3 )
# Perform linear regression analysis
regression_model_3 <- lm(voteshare ~ presvote, data = inc.sub)
# Check the result of regression model
summary(regression_model_3)
# Take the coefficients from model
coefficients_package_3 <- coef(regression_model_3)
print(coefficients_package_3)
# Sort the coefficients from coefficients package
intercept_3 <- coefficients_package_3[1]
print(round(intercept_3, digits = 2))
coef_presvote_3 <- coefficients_package_3[2]
print(round(intercept_3, digits = 2))
# Sort the coefficients from coefficients package
intercept_3 <- coefficients_package_3[1]
print(round(intercept_3, digits = 2))
coef_presvote_3 <- coefficients_package_3[2]
print(round(coef_presvote_3, digits = 2))
# Perform linear regression analysis
regression_model_4 <- lm(residuals ~ residuals_2, data = inc.sub)
# Check the result of regression model
summary(regression_model_4)
# Take the coefficients from model
coefficients_package_4 <- coef(regression_model_4)
print(coefficients_package_4)
# Sort the coefficients from coefficients package
intercept_4 <- coefficients_package_4[1]
print(round(intercept_4, digits = 2))
coef_residuals_2_4 <- coefficients_package_4[2]
print(round(coef_residuals_2_4, digits = 2))
# Perform linear regression analysis
regression_model_5 <- lm(voteshare ~ difflog + presvote, data = inc.sub)
# Check the result of regression model
summary(regression_model_5)
# Take the coefficients from model
coefficients_package_5 <- coef(regression_model_5)
print(coefficients_package_5)
# Sort the coefficients from coefficients package
intercept_5 <- coefficients_package_5[1]
print(round(intercept_5, digits = 2))
coef_difflog_5 <- coefficients_package_5[2]
print(round(coef_difflog_5, digits = 2))
coef_presvote_5 <- coefficients_package_5[3]
print(round(coef_presvote_5, digits = 2))
# Save coefficients
beta_Democracy <- -9.616
se_Democracy <- 9.312
# Step1: State a null and alternative (two-tailed) hypothesis.
# H0: beta_Democracy = 0 VS. HA: beta_Democracy != 0
# Step2: Check the standard error(SE)
se_Democracy <- 9.312
# Step3: calculate Test statistic
# and the formula is: Test statistic = Estimate - 0 / SE
t_statistic_Democracy <- (beta_Democracy-0)/se_Democracy
print(t_statistic_Democracy)
# Step4: calculate degree of freedom
df <- 1000-3-1
print(df)
# Step5:calculate p-value when two tailed
p_value_ <- 2 * (1 - pt(abs(t_statistic_2), df))
# Question 1
# (a)
# 解释见zetoro
# (b)
# Conduct T-test to test the significance of the coefficient of Democracy
# Save coefficients
beta_Democracy <- -9.616
se_Democracy <- 9.312
# Step1: State a null and alternative (two-tailed) hypothesis.
# H0: beta_Democracy = 0 VS. HA: beta_Democracy != 0
# Step2: Check the standard error(SE)
se_Democracy <- 9.312
# Step3: calculate Test statistic
# and the formula is: Test statistic = Estimate - 0 / SE
t_statistic_Democracy <- (beta_Democracy-0)/se_Democracy
print(t_statistic_Democracy)
# Step4: calculate degree of freedom
df <- 1000-3-1
print(df)
# Step5:calculate p-value when two tailed
p_value_ <- 2 * (1 - pt(abs(t_statistic_Democracy), df))
print(p_value)
y_hat_low <- 26.51 -4*7420.82 -2.769*11.99
print(y_hat_low)
y_hat_high <- 26.51 -4*43038.56 -2.769*11.99
print(y_hat_high)
y_hat_diff <- -29 - (-17)
print(y_hat_diff)
y_hat_diff <- abs(-29 - (-17))
print(y_hat_diff)
y_hat_diff <- abs(y_hat_low - y_hat_high)
print(y_hat_diff)
y_hat_diff <- abs(y_hat_high) - abs(y_hat_low)
print(y_hat_diff)
library(tidyverse) # load our packages here
library(rvest)
library(xml2)
html <- read_html(bowlers)
bowlers <- "https://stats.espncricinfo.com/ci/content/records/93276.html"
html <- read_html(bowlers)
html
bowlers <- "https://stats.espncricinfo.com/ci/content/records/93276.html"
html <- read_html(bowlers)
html
# We can inspect the structure of this html using xml_structure() from xml2
xml_structure(html)
capture.output(xml_structure(html))
html %>%
html_nodes("table")
html %>%
html_nodes(".ds-table") # try searching using the class (add a dot)
html %>%
html_nodes(xpath = "//table")
tab1 <- html %>%
html_nodes()
tab1 <- html %>%
html_nodes(xpath = "//table")
tab1 <- html %>%
html_nodes(xpath = "//table[position()=1")
html %>%
html_nodes(xpath = "//table[position()=1")
html %>%
html_nodes(xpath = "//table[position()=1]")
tab1 <- html %>%
html_nodes(xpath = "//table/thead | //tbale/tbody")
html %>%
html_nodes(xpath = "//table")
tab1 <- html %>%
html_nodes(xpath = "///table[position()=1]")
tab2 <- tab1 %>%
html_nodes(xpath = "//table/thead | //tbale/tbody")
"table"
".ds-table"
xpath = "//table[position() = 1]"
xpath = "//table/thead | //table/tbody"
cricket <- html_table(tab1, header = TRUE)[[1]]
```{r scrape URLs}
url <- "https://www.mfa.gr/en/current-affairs/statements-speeches/?page=0" #add the URL here as a string
gu_api_key()
## Load packages
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
lapply(c("tidyverse",
"guardianapi", # for working with the Guardian's API
"quanteda", # for QTA
"quanteda.textstats", # more Quanteda!
"quanteda.textplots", # even more Quanteda!
"readtext", # for reading in text data
"stringi", # for working with character strings
"textstem" # an alternative method for lemmatizing
), pkgTest)
### A. Using the Guardian API with R
gu_api_key() # run this interactive function
# We want to query the API on articles featuring Ukraine since Jan 1 2023
dat <- gu_content(query = "Ukraine", from_date = "2023-01-01") # making a tibble
# We want to query the API on articles featuring Ukraine since Jan 1 2023
dat <- gu_content(query = "Ukraine", from_date = "2023-01-01") # making a tibble
# We'll save this data
saveRDS(dat, "data/df2023")
#####################
# load libraries
# set wd
# clear global .envir
#####################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# here is where you load any necessary packages
# ex: stringr
# lapply(c("stringr"),  pkgTest)
lapply(c(),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
lapply(c(),  pkgTest)
lapply(c(),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Set seeds to ensure reproducibility
set.seed(123)
# Generate 1000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Create empirical distribution of observed data
ECDF <- ecdf(data)
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# here is where you load any necessary packages
# ex: stringr
# lapply(c("stringr"),  pkgTest)
lapply(c(),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#####################
# Problem 1
#####################
# Set seeds to ensure reproducibility
set.seed(123)
# Generate 1000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Create empirical distribution of observed data
ECDF <- ecdf(data)
# Set seeds to ensure reproducibility
set.seed(123)
# Generate 1000 Cauchy random variables
cauchy_data <- rcauchy(1000, location = 0, scale = 1)
# Create empirical distribution of observed data
ECDF <- ecdf(cauchy_data)
empiricalCDF <- ECDF(cauchy_data)
empiricalCDF
theoretical_CDF <- pnorm(cauchy_data)
theoretical_CDF
D <- max(abs(empiricalCDF - theoretical_CDF))
D
p_value <- sqrt(2 * pi) * D * sum(exp(-(2*(1:1000)-1)^2 * pi^2 / (8 * D^2)))
# Print results
print(p_value)
# Check the results using ks.test()
results <- ks.test(sempiricalCDF, theoretical_CDF)
results <- ks.test(empiricalCDF, theoretical_CDF)
# Print results
print(results)
p_value <- sqrt(2 * pi) / D * sum(exp(-(2*(1:1000)-1)^2 * pi^2 / (8 * D^2)))
# Print p value
print(p_value)
p_value <- sqrt(2 * pi) / D * sum(exp(-(2*(1:1000)-1)^2 * pi^2 / (8 * D^2)))
# Print p value
print(p_value)
## Load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
lapply(c("tidyverse"),  pkgTest)
## Reading in the data
#  Option 1:
#  Using stringsAsFactors
graduation <- read.table("http://statmath.wu.ac.at/courses/StatsWithR/Powers.txt",
stringsAsFactors = TRUE)
#  Option 2:
#  Parse column names as a vector to colClasses
graduation <- read.table("http://statmath.wu.ac.at/courses/StatsWithR/Powers.txt",
colClasses = c("hsgrad" = "factor",
"nonwhite" = "factor",
"mhs" = "factor",
"fhs" = "factor",
"intact" = "factor"))
summary(graduation)
mod <- glm(hsgrad ~ ., # period functions as omnibus selector (kitchen sink additive model)
data = graduation,
family = "binomial")
mod <- glm(hsgrad ~ .,
data = graduation,
family = binomial(link = "logit")) # same as above (logit is default arg)
summary(mod)
nullMod <- glm(hsgrad ~ 1, # 1 = fit an intercept only (i.e. sort of a "mean")
data = graduation,
family = "binomial")
#  Run an anova test on the model compared to the null model
anova(nullMod, mod, test = "Chisq")
anova(nullMod, mod, test = "LRT") # LRT is equivalent
##  Extracting confidence intervals (of the coefficients)
?confint
exp(confint(mod)) # Remember: transform to odds ratio using exp()
?confint
exp(confint(mod)) # Remember: transform to odds ratio using exp()
# An option for making a data.frame of confidence intervals and coefficients
confMod <- data.frame(cbind(lower = exp(confint(mod)[,1]),
coefs = exp(coef(mod)),
upper = exp(confint(mod)[,2])))
ggplot(data = confMod, mapping = aes(x = row.names(confMod), y = coefs)) +
geom_point() +
geom_errorbar(aes(ymin = lower, ymax = upper), colour = "red") +
coord_flip() +
labs(x = "Terms", y = "Coefficients")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
summary(lm_model)
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
summary(lm_model)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
summary(lm_model)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef(c(0, 1)), function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
optim_model <- optim(coef=c(0, 1),
fn=function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
# Set seeds to ensure reproducibility
set.seed (123)
# Create dataframe
data <- data.frame(x = runif(200, 1, 10))
data$y <- 0 + 2.75*data$x + rnorm(200, 0, 1.5)
# Perform OLS linear regression using the lm() function
lm_model <- lm(y ~ x, data = data)
summary(lm_model)
# 使用 optim() 函数执行 BFGS 算法线性回归
optim_model <- optim(coef=c(0, 1),
fn=function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
optim_model <- optim(par=c(0, 1),
fn=function(coef) {
sum((data$y - (coef[1] + coef[2] * data$x))^2)
}, method = "BFGS")
print(optim_model$par)
print(lm_model[1])
print(lm_model[2])
print(optim_model$par[1])
print(optim_model$par[2])
print(lm_model[1])
print(optim_model$par[1])
print(optim_model$par[2])
